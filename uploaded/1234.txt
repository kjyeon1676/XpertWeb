#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <sql.h>
#include <sqlext.h>

SQLHENV		henv;  //환경설정
SQLHDBC		hdbc1; // 데이터베이스 conn 다룸
SQLHSTMT	hstmt1;//스테이트먼트 같은 느낌!

void wmain()
{
	/*
	SQLWCHAR      SqlState[12], Msg[SQL_MAX_MESSAGE_LENGTH];
	SQLINTEGER    NativeError;
	SQLSMALLINT   i, MsgLen;
	unsigned char szData[1000];
	*/
	SQLRETURN retcode; //에스큐엘 리턴? => 에러 코드 종류 받아내는거 약간 자바의 exception 같은 느낌.
	char dname[30], gen[30], pname[30], sname[30];
	int		sid;
	float	grade;
	int		len1, len2, len3, len4, len5,len6;

	if ((retcode = SQLAllocEnv(&henv)) != SQL_SUCCESS) //sql환경할당을 하는데 실패하면
		printf("SQLAllocEnv: error code = %d\n", retcode); //에러코드 출력
	if ((retcode = SQLAllocConnect(henv, &hdbc1)) != SQL_SUCCESS) //에스큐엘 conn할당하는데 실패하면
		printf("SQLAllocConnect: error code = %d\n", retcode); //에러코드 출력
	if ((retcode = SQLConnect(hdbc1, (SQLWCHAR *)TEXT("ODBC_DBCLASS"), SQL_NTS, (SQLWCHAR *)TEXT("scott"), SQL_NTS, (SQLWCHAR *)TEXT("tiger"), SQL_NTS)) != SQL_SUCCESS)
	//sqlwchar*TEXT("문자열")은  문자열 상수의 경우임
	{//SQL연결하는데 hdbc1(conn)을 오픈하고, 파라메타를 ODBC_DBCLASS를주고 SQL_NTS로 null terminated string. ~~주고 실패하면 에러출력
		printf("SQLConnect: error code = %d\n", retcode);
		/*
		i= 1;
		while ((retcode = SQLGetDiagRec(SQL_HANDLE_DBC, hdbc1, i, (SQLWCHAR *)SqlState,
		&NativeError, (SQLWCHAR *)Msg, sizeof(Msg), &MsgLen) != SQL_NO_DATA)) {
		sprintf_s((char *)szData, sizeof(szData), "Error:\nSQLSTATE=%s, Native error=%ld, msg='%s'", SqlState, NativeError, Msg);
		printf("%s\n", szData);
		for (int j = 0; j < 10; j++)
		printf_s("%c", SqlState[j]);
		i++;
		}
		*/
	}

	SQLAllocStmt(hdbc1, &hstmt1); //conn이랑 stmt 연결함~~~(할당)

	while (1)
	{
		printf("학과이름을 입력하세요 : \n");
		fgets(dname, sizeof(dname), stdin);

		retcode = SQLPrepare(hstmt1, (SQLWCHAR *)"select sid,sname,decode(gen, 'M', '남학생', '여학생') gen,grade,dname,pname from student s,department d,professor p where s.deptno = d.deptno and s.advisor= p.pid and d.deptno=p.deptno and d.dname = ?;", SQL_NTS);
		SQLBindParameter(hstmt1,1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 0, 0, &dname,0,0);
		SQLExecute(hstmt1);
		if (retcode == SQL_SUCCESS) { //성공이면 
			printf("Success of SQLPrepare\n");
			retcode = SQLBindCol(hstmt1, 1, SQL_C_LONG, &sid, 0, (SQLINTEGER *)&len1); //SQLBindCol은 결과값을 받아서 속성별로  맞춰서 변수에 넣어줌.
			retcode = SQLBindCol(hstmt1, 2, SQL_C_CHAR, &sname, 30, (SQLINTEGER *)&len2);
			retcode = SQLBindCol(hstmt1, 3, SQL_C_CHAR, &gen, 30, (SQLINTEGER *)&len3);
			retcode = SQLBindCol(hstmt1, 4, SQL_C_FLOAT, &grade, 0, (SQLINTEGER *)&len4);
			retcode = SQLBindCol(hstmt1, 5, SQL_C_CHAR, &dname, 30, (SQLINTEGER *)&len5);
			retcode = SQLBindCol(hstmt1, 6, SQL_C_CHAR, &pname, 30, (SQLINTEGER *)&len6);
			while (SQLFetch(hstmt1) == SQL_SUCCESS)
				printf("sid = %d, sname = %s, gen = %s, grade = %.2f, dname = %s, pname = %s\n", sid,sname,gen, grade,dname,pname);
		}
		else
			printf("Something wrong in SQLExecDirect. Error code = %d\n", retcode);
	}

	SQLFreeStmt(hstmt1, SQL_DROP);
	SQLDisconnect(hdbc1);
	SQLFreeConnect(hdbc1);
	SQLFreeEnv(henv);
}